# 浏览器

## HTTP缓存

`HTTP`属于客户端缓存，我们常认为浏览器有一个缓存数据库，用来保存一些静态文件，下面我们分为以下几个方面来简单的介绍`HTTP`缓存。

- 缓存的规则
- 缓存的方案
- 缓存的优点
- 不同刷新的请求执行过程

### 缓存的规则

缓存分为**强制缓存**和**协商缓存**。

#### 强制缓存

当缓存数据库中有客户端需要的数据，客户端直接将数据从缓存数据库中拿出来使用（如果数据未失效），当缓存数据库中没有需要的数据时，客户端才会向服务器请求。

#### 协商缓存

**协商缓存**又称为对比缓存，客户端会先从缓存数据库中拿到一个缓存标识，然后向服务器验证缓存是否失效，如果没有失效服务端会返回`304`，这样客户端会直接去缓存数据库中拿出数据，如果失效，服务端会返回新的数据。

**强制缓存**的优先级高于**协商缓存**，若两种缓存都存在，且**强制缓存为命中目标**，则协商缓存不再验证规则。

### 缓存的方案

上面的内容让我们大概了解了缓存机制是这样运行的，但是，服务器是如何判断缓存是否失效呢？我们知道浏览器和服务器进行交互的时候会发送一些请求数据和响应数据，我们称之为`HTTP`报文，报文中包含首部`header`和主体部分`body`，与缓存相关的规则信息就包含在`header`中，`body`中的内容是`HTTP`请求真正要传输的部分。

#### 强制缓存

对于强制缓存，服务器响应的`header`中会用两个字段来表明-Expires和Cache-Control。

##### Expires

**Expires**的值为服务端返回的数据的到期时间，当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据，但由于服务端时间和客户端时间可能存在误差，这也可能导致缓存命中的误差，另外一方面，**Expires**是`HTTP1.0`的产物，因此大多数使用**Cache-Control**代替。

##### Cache-Control

**Cache-Control**有很多属性，不同的属性代表的意义也不同。

- private：客户端可以缓存
- public：客户端和代理服务器都可以缓存
- max-age=t：缓存内容将在t秒后消失
- no-cache：需要使用协商缓存来验证数据
- no-store：所有内容都不会缓存

#### 协商缓存

协商缓存是需要进行对比判断是否可以进行缓存，浏览器第一次请求数据时，服务器会将请求标识与数据在一起响应给客户端，客户端将它们备份在缓存中，再次请求时，客户端会将缓存中标识发送给服务器，服务器根据此标识判断，若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。

##### Last-Modified

**Last-Modified**：服务器在响应请求时，会告诉浏览器资源的最后修改时间。

- if-Modifed-Since：浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获取的最后修改时间，服务端接收到此请求头发现有**if-Modified-Since**，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只要从缓存中获取信息即可。
- 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
- 如果没有被修改：那么只需要传输响应header,服务器返回304 Not Modified
- if-Unmodified-Since：从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改
  - 如果没有被修改：则开始“继续”传输文件，服务器返回：200 OK
  - 如果文件被修改：则不传输，服务器返回：412 Precondtion failed（预处理错误）

这两个的区别是一个是修改了才下载一个是没修改才下载。

Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。

#### Etag

Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）。

- If-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。
  - 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。
  - 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304

但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。

### 缓存的优点

- 减少了冗余的数据传递，节省宽带流量
- 减少了服务器的负担，大大提高了网站性能
- 加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因

### 不同刷新的请求执行过程

#### 浏览器地址栏中写入URL，回车

- 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）

#### 按F5

- F5就是告诉浏览器，要去服务器看看这个文件是否过期，于是浏览器就就兢兢业业的发送一个请求带上**if-Modified-Since**。

#### Ctrl+F5

- 告诉浏览器，先把缓存中的这个文件给删除了，然后在去服务器请求完整的资源文件下来，于是客户端就完成了强行更新的操作。

### 服务器处理请求并返回HTTP报文

首先会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用，这一部分工作一般是由Web服务器进行，HTTP报文分为**状态码**，**响应报头**和**响应报文**。

#### 状态码

状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

- 1xx：指示信息–表示请求已接收，继续处理。
- 2xx：成功–表示请求已被成功接收、理解、接受。
- 3xx：重定向–要完成请求必须进行更进一步的操作。
- 4xx：客户端错误–请求有语法错误或请求无法实现。
- 5xx：服务器端错误–服务器未能实现合法的请求。

平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500

#### 常见状态码区别

##### 200 成功

请求成功，通常服务器提供了需要的资源。

#### 204 无内容

服务器成功处理了请求，但没有返回任何内容。

#### 301 永久移动

请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。

#### 302 临时移动

服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

#### 304 未修改

自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。

#### 400 错误请求

服务器不理解请求的语法。

#### 401 未授权

请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。

#### 403 禁止

服务器拒绝请求。

#### 404 未找到

服务器找不到请求的网页。

#### 422 无法处理

请求格式正确，但是由于含有语义错误，无法响应

#### 500 服务器内部错误

服务器遇到错误，无法完成请求。

### 响应报头

常见的响应报头字段有: Server, Connection...。

### 响应报文

你从服务器请求的HTML,CSS,JS文件就放在这里面

## 浏览器解析渲染页面

就是`Webkit`解析渲染页面的过程。

- 解析HTML形成DOM树
- 解析CSS形成CSSOM树
- 合并DOM和CSSOM树形成渲染树
- 浏览器开始渲染并绘制页面

这个过程比较重要的两个概念就是`回流`和`重绘`，DOM结点都是以盒模型存在的，需要浏览器去计算位置和宽度，这个过程就是`回流`。等到页面的宽度，高度，大小，颜色等属性确定下来之后，浏览器开始绘制内容，这个过程叫做重绘。浏览器刚一打开页面一定是经历这两个过程的，但是这个过程是很消耗性能的，所以应该尽量避免`回流`和`重绘`。

### 性能优化之回流和重绘

#### 回流

当`Render Tree`中部分或者全部元素的尺寸、结构或者某些属性发生改变时，浏览器重新渲染部分或者全部文档的过程称为`回流`。

会导致回流的操作：

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或者位置发生改变
- 元素的内容变化
- 元素字体大小发生改变
- 添加或者删除可见的DOM元素
- 激活CSS伪类
- 查询某些属性或者调用某些方法

一些常见且会导致回流的属性和方法。

- clientWidth、clientHeight、clientTop、clientLeft
- offsetWidth、offsetHeight、offsetTop、offsetLeft
- scrollWidth、scrollHeight、scrollTop、scrollLeft
- scrollIntoView()、scrollIntoViewIfNeeded()
- getComputedStyle()
- getBoundingClientRect()
- scrollTo()

#### 重绘

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并且重新绘制它，这个过程称为重绘。

#### 优化

##### CSS

- 避免使用table布局
- 尽可能在DOM树的最末端改变class
- 避免设置多层内联样式
- 将动画效果应用到position属性为`absolute`和`fixed`的元素上
- 避免使用CSS表达式（例如calc()）

##### JavaScript

- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
- 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

##### JS解析

JS解析是由浏览器的JS引擎完成的，由于JavaScript是单线程运行，也就是说一个时间只能干一件事，干这件事的时候其他事情都在排队，但是有些比较耗时（例如IO操作）所以将任务分为**同步任务**和**异步任务**，所有的同步任务都放在主线程上执行，形成执行栈，异步任务等待，当执行栈任务清空时才会去查看异步任务有没有需要执行的，有再提取到主线程，这样往复循环，就形成了事件循环（Event Loop）。

## JavaScript

JavaScript是一门单线程语言，尽管H5提出了`Web-worker`，能够模拟实现多线程，但本质上还是单线程。

### 事件循环

既然是单线程，每个事件的执行就要有顺序，比如你去银行取钱，前面的在进行，后面的就得排队等待，这很耗时，并且性能很差，因此浏览器的JS引擎处理JavaScript分为**同步任务**和**异步任务**。

- 同步任务和异步任务分别进入不同的场合，同步任务进入主线程，异步任务进入`Event Table`并注册函数。
- 当指定的事情完成时，`Event Table`会将这个函数移入`Event Queue`。
- 主线程的任务执行完毕为空，会去`Event Queue`读取对应的函数，进入主线程执行。
- 上诉过程不断重复，也就是常说的`Event Loop`(事件循环)。

JS引擎存在`monitoring process`进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。估计看完这些你对事件循环有一定的了解，但是事实上我们看对的没这么简单，通常我们会看到Promise，setTimeout，process.nextTick（），这个时候你和我就懵逼。

**除了`同步任务`和`异步任务`，我们还分为`宏任务`和`微任务`，常见的有以下几种**

- macro-task(宏任务)：包括整体代码`script`，`setTimeout`，`setInterval`
- micro-task(微任务)：包括`Promise`，`process.nextTick`

不同的任务会进入不同的任务队列来执行，JS引擎开始工作后，先在`宏任务`开始第一次循环（`script里面先执行`），当主线程执行栈全部任务被清除后去微任务看看，如果有等待执行的任务，执行全部的微任务，再从宏任务找最先进入队列的任务执行，执行这个任务后再去主线程执行任务，执行栈被清空之后再去执行微任务，以此类推进行循环。

**微任务会全部执行，而宏任务会一个一个来执行**。